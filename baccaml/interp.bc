(* -*- mode: tuareg -*- *)

let rec frame_reset stack old_base new_base ret n i =
  if n = i then (stack.(old_base + n) <- ret; old_base + n + 1)
  else (stack.(old_base + i) <- stack.(new_base + i);
        frame_reset stack old_base new_base ret n (i + 1)) in

(* declaring a casting function: int array -> int *)
let rec cast_fAII x = x in
(* declaring a casting function: int -> int array *)
let rec cast_fIAI x = x in

let rec frame_reset stack old_base new_base ret n i =
  if n = i then (stack.(old_base + n) <- ret; old_base + n + 1)
  else (stack.(old_base + i) <- stack.(new_base + i);
        frame_reset stack old_base new_base ret n (i + 1)) in

let rec pop stack sp = stack.(sp - 1) in
let rec push stack sp v = stack.(sp) <- v in

let rec interp stack sp bytecode pc =
  let instr = bytecode.(pc) in
  if instr = 1 then               (* ADD *)
    let v2 = stack.(sp - 1) in    (* sp: sp - 1 *)
    let v1 = stack.(sp - 2) in    (* sp: sp - 2 *)
    stack.(sp - 2) <- (v1 + v2);  (* sp: sp - 1 *)
    interp stack (sp - 1) bytecode (pc + 1)
  else if instr = 2 then          (* SUB *)
    let v2 = stack.(sp - 1) in
    let v1 = stack.(sp - 2) in
    stack.(sp - 2) <- (v1 - v2);
    interp stack (sp - 1) bytecode (pc + 1)
  else if instr = 3 then          (* MUL *)
    let v2 = stack.(sp - 1) in
    let v1 = stack.(sp - 2) in
    stack.(sp - 2) <- (v1 * v2);
    interp stack (sp - 1) bytecode (pc + 1)
  else if instr = 4 then          (* NOT *)
    let v = stack.(sp - 1) in
    let n = (if v = 0 then 1 else 0)in
    stack.(sp - 1) <- n;
    interp stack sp bytecode (pc + 1)
  else if instr = 5 then          (* LT *)
    let v2 = stack.(sp - 1) in
    let v1 = stack.(sp - 2) in
    let n = (if v1 < v2 then 1 else 0) in
    stack.(sp - 2) <- n;
    interp stack (sp - 1) bytecode (pc + 1)
  else if instr = 6 then          (* EQ *)
    let v1 = stack.(sp - 1) in
    let v2 = stack.(sp - 2) in
    let v = (if v1 = v2 then 1 else 0) in
    stack.(sp - 2) <- v;
    interp stack (sp - 1) bytecode (pc + 1)
  else if instr = 14 then         (* CONST *)
    let c = bytecode.(pc + 1) in
    stack.(sp) <- c;
    interp stack (sp + 1) bytecode (pc + 2)
  else if instr = 7 then          (* JUMP_IF_ZERO *)
    let addr = bytecode.(pc + 1) in
    let v = stack.(sp - 1) in
    let sp2 = sp - 1 in
    if v = 0 then (
      interp stack sp2 bytecode addr
    ) else
      interp stack sp2 bytecode (pc + 2)
  else if instr = 9 then          (* CALL *)
    let addr = bytecode.(pc + 1) in
    stack.(sp) <- pc + 2;
    interp stack (sp + 1) bytecode addr
  else if instr = 22 then         (* CALL_HS *)
    let addr = bytecode.(pc + 1) in
    stack.(sp) <- pc + 2;
    interp stack (sp + 1) bytecode addr
  else if instr = 10 then         (* RET *)
    let v = stack.(sp - 1) in
    let n = bytecode.(pc + 1) in
    let addr = stack.(sp - 2) in  (* sp: sp - 2 *)
    stack.(sp - n - 2) <- v;      (* sp: sp - 2 - n + 1 = sp - 1 - n *)
    let sp2 = sp - n - 1 in
    interp stack sp2 bytecode addr
  else if instr = 11 then         (* HALT *)
    stack.(sp - 1)
  else if instr = 12 then         (* DUP *)
    let n = bytecode.(pc + 1) in
    let v = stack.(sp - n - 1) in
    stack.(sp) <- v;
    interp stack (sp + 1) bytecode (pc + 2)
  else if instr = 13 then         (* POP1 *)
    let v = stack.(sp - 1) in
    let _ = stack.(sp - 2) in
    stack.(sp - 2) <- v;
    interp stack (sp - 1) bytecode (pc + 1)
  else if instr = 18 then         (* FRAME_RESET *)
    let o = bytecode.(pc + 1) in
    let l = bytecode.(pc + 2) in
    let n = bytecode.(pc + 3) in
    let ret = stack.(sp-n-l-1) in
    let old_base = sp - n - l - o - 1 in
    let new_base = sp - n in
    let sp2 = frame_reset stack old_base new_base ret n 0 in
    interp stack sp2 bytecode (pc + 4)
  else if instr = 13 then         (* JUMP *)
    let addr = bytecode.(pc + 1) in
    interp stack sp bytecode addr
  else if instr = 15 then         (* GET *)
    let n = stack.(sp - 1) in
    let arr = cast_fIAI(stack.(sp - 2)) in
    stack.(sp - 2) <- arr.(n);
    interp stack (sp - 1) bytecode (pc + 1)
  else if instr = 16 then         (* PUT *)
    let n = stack.(sp - 1) in
    let i = stack.(sp - 2) in
    let arr = cast_fIAI(stack.(sp - 3)) in
    arr.(i) <- n;
    interp stack (sp - 3) bytecode (pc + 1)
  else if instr = 17 then         (* ARRAYMAKE *)
    let init = stack.(sp - 1) in
    let size = stack.(sp - 2) in
    let a = Array.make size init in
    stack.(sp - 2) <- cast_fAII(a);
    interp stack (sp - 1) bytecode (pc + 1)
  else if instr = 20 then         (* POP0 *)
    let _ = stack.(sp - 1) in
    interp stack (sp - 1) bytecode (pc + 1)
  else if instr = 21 then         (* METHOD_ENTRY *)
    interp stack sp bytecode (pc + 1)
  else if instr = 22 then        (* CONST0 *)
    (stack.(sp) <- 0;
     interp stack (sp + 1) bytecode (pc + 1))
  else if instr = 23 then        (* DUP0 *)
    let v = stack.(sp - 1) in
    stack.(sp) <- v;
    interp stack (sp + 1) bytecode (pc + 1)
  else
    -1000 in
let stk = Array.make 10 1 in
let code = Array.make 1 11 in
print_int (interp stk 1 code 0)
